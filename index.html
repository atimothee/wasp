<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Wasp : Android network library">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
      <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>

    <title>Wasp</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/orhanobut/wasp">View on GitHub</a>

<a id='social-share' href="https://twitter.com/share" class="twitter-share-button" data-url="http://orhanobut.github.io/wasp" data-text="Wasp: Android network solution" data-size="large" data-count="none" data-hashtags="android">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          <h1 id="project_title">Wasp</h1>
          <h2 id="project_tagline">Android Network Solution</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/orhanobut/wasp/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/orhanobut/wasp/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>Introduction</h2>
      <p>Wasp is a compact, complete, easy-in-use network library based on Volley currently.</p>
      <b><p>Wasp uses:</p></b>
      <ul>
        <li>Volley</li>
        <li>Gson</li>
        <li>OkHttp</li>
      </ul>
      <p><b>Wasp provides</b></p>
      <ul>
        <li>Easy implementation</li>
        <li>Mocking network calls</li>
        <li>Easy-in-use image management</li>
        <li>Request Interceptor to add attributes (query params, headers, retry policy) to each call</li>
        <li>Call based headers</li>
        <li>Call based endpoint url</li>
        <li>Call based retry policy</li>
        <li>Cookie management</li>
        <li>Certificate management</li>
        <li>Easy-in-use auth token management</li>
      </ul>
      
      <h2>Gradle</h2>
      <pre class='prettyprint'>
compile 'com.orhanobut:wasp:1.8'
</pre>

     <h2>Usage</h2>
<hr>
     <h4>Create your service class</h4>
     <p>Create a service interface and define all your network calls</p>
     <p><b>@GET,@DELETE,@POST,@PUT</b> can be used for http method.</p>
     <p><b>@Path</b> is used for replacement for specific words in the url. </p>
<pre class='prettyprint'>
public interface GitHubService {

    @GET("/repos/{user}/{repo}")
    void fetchRepo(
          @Path("user") String user,
          @Path("repo") String repo,
          CallBack&lt;List&lt;Repo>> callBack
    );

    @POST("/repos/{user}/{repo}")
    void addRepo(
          @Path("user") String user,
          @Path("repo") String repo,
          CallBack&lt;Repo> callBack
    );
}</pre>
<pre class='prettyprint'>
    service.fetchRepo("admin","wasp",callback);
    //url will be ENDPOINT/repos/admin/wasp
</pre>
     <h4>Initialize builder</h4>
     <p>Best approach would be to initialize it in the application class and use it as singleton.</p>
<pre class='prettyprint'>
 GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   // Must be set
        .setLogLevel(LogLevel.FULL)              // Optional, default NONE   
        .setParser(new GsonParser())             // Optional, default Gson
        .trustCertificates()                     // Optional
        .enableCookies(CookiePolicy.ACCEPT_ALL)  // Optional
        .setHttpStack(new OkHttpStack())         // Optional
        .build()                                 // Must be called
        .create(MyService.class);                // Must be called 
</pre>



     <h4>Use it everywhere</h4>
     <p>Use the service instance to make network calls</p>
<pre class='prettyprint'>
service.fetchRepo("github","wasp", new CallBack&lt;List&lt;Repo>>{
      
      @Override
      public void onSuccess(List&lt;Repo> repos) {
      }

      @Override
      public void onError(WaspError error) {
      }
});
</pre>


     <h4>Add Body</h4>
     <p><b>@Body</b> can be used to add an object for request body. Object will be converted to json.</p>
<pre class='prettyprint'>
    @POST("/repos")
    void addName(
        @Body Repo repo,
        CallBack&lt;Repo> callBack
    );
</pre>
<pre class='prettyprint'>
    service.addName(new Repo("3423",3),callback);
</pre>
      <p><b>@BodyMap</b> can be used to add a Map object instead of creating body class. It will be converted to json. You can use
      @BodyMap for the simple operations which you don't want to create a class.</p>
<pre class='prettyprint'>
    @POST("/repos")
    void addName(
        @BodyMap Map map,
        CallBack&lt;Repo> callBack
    );
</pre>
<pre class='prettyprint'>
    Map<String,Object> map = new HashMap<>();
    map.put("ip","3423");
    map.put("page",3);
    
    service.addName(map, callback);
</pre>

     <h4>Add Query Params</h4>
     <p><b>@Query</b> is used to add query params</p>
<pre class='prettyprint'>
    @GET("/users/repos")
    void fetchRepoBySearch(
          @Query("page") int pageNumber,
          @Query("sort") String sort,
          CallBack&lt;Repo> callBack
    );
</pre>
<pre class='prettyprint'>
    service.fetchRepoBySearch(2,"asc", callback);
    //output url is ENDPOINT/users/repos?page=2&sort=asc
</pre>
     <p><b>@QueryMap</b> is used to add query params using a map</p>
<pre class='prettyprint'>
    @GET("/users/repos")
    void fetchRepoBySearch(
          @QueryMap Map queryParamsMap,
          CallBack&lt;Repo> callBack
    );
</pre>
<pre class='prettyprint'>
    Map&lt;String,String> map = new HashMap<>();
    map.put("sort","asc");
    map.put("offset", "100");
    
    service.fetchRepoBySearch(map, callback);
</pre>


     <h4>Add Headers</h4>
     <p><b>@Header</b> is used to add headers by using params</p>
<pre class='prettyprint'>
    @GET("/repos")
    void fetchRepos(
          @Header("auth") String authToken,
          RepoCallBack&lt;List&lt;Repo> callBack
    );
</pre>
      <p><b>@Headers</b> is used to add static headers by adding to method</p>
<pre class='prettyprint'>
    //Single static header
    @Headers("Accept-Language:en-En")
    @GET("/users")
    void fetchUsers(
          RepoCallBack&lt;List&lt;User> callBack
    );

    // Multiple static headers
    @Headers({
        "Accept-Language:en-En",
        "Content-type:application/json"
    })
</pre>

     <h4>Request Interceptor</h4>
     <p>You can intercept each request and add some additional information. You can either implement RequestInterceptor
       interface or use the SimpleInterceptor class. Use SimpleInterceptor if you don't need to implement each feature.
     </p>
     <p>Add headers to each request</p>
<pre class='prettyprint'>
  RequestInterceptor interceptor = new SimpleInterceptor() {
      @Override                                                
      public void onHeadersAdded(Map<String, String> headers) {
          super.onHeadersAdded(headers);                       
          headers.put("key","value");                          
      }                                                        
  }</pre>

     <p>Add additional query parameters to the each request</p>
<pre class='prettyprint'>
  RequestInterceptor interceptor = new SimpleInterceptor() {
      @Override
      public void onQueryParamsAdded(Map<String, Object> params) {
          super.onQueryParamsAdded(params);
          params.put("name","something");
      }                                                       
  }</pre>
     <p>Add retry policy to the each request</p>
<pre class='prettyprint'>
  RequestInterceptor interceptor = new SimpleInterceptor() {
      @Override
      public WaspRetryPolicy getRetryPolicy() {
          return new WaspRetryPolicy(45000, 3, 1.5f);
      }                                                      
  }</pre>
  
    <p>Add auth token to the each request or filtered requests. Return a new AuthToken object which accepts
      authtoken value and filter enabled. If you enabled the filter, all request which has @Auth annotation
      will use the auth token in the header. If you disabled filter, each request will add the token.
    </p>
<pre class='prettyprint'>
  RequestInterceptor interceptor = new SimpleInterceptor() {
      @Override
      public AuthToken getAuthToken() {
          return new AuthToken(token, true);
      }                                                     
  }</pre>
  <p></p>
<pre class='prettyprint'>
    @Auth
    @GET("/users")
    void fetchUsers(
          RepoCallBack&lt;List&lt;User> callBack
    );
</pre>
<p>And finally set it to the builder</p>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        <b>.setRequestInterceptor(interceptor)</b>        
        .build()                        
        .create(MyService.class);   
</pre>

     <h4>Retry Policy</h4>
     <p>You can set retry policy for each call by using request interceptor</p>
<pre class='prettyprint'>
  RequestInterceptor interceptor = new SimpleInterceptor() {
      @Override
      public WaspRetryPolicy getRetryPolicy() {
          return new WaspRetryPolicy(45000, 3, 1.5f);
      }                                                      
  }</pre>
       <p>You can use annotation to add specific policy for the specific calls. 
       Annotation always override the request interceptor if both are used at the same time
       </p>
<pre class='prettyprint'>
    @RetryPolicy(timeout = 10000)
    @GET("/users")
    void fetchUsers(
          RepoCallBack&lt;List&lt;User>> callBack
    );
</pre>


     <h4>Http Stack</h4>
     <p>You can set your custom http stack instead of default. Default is OkHttp.</p>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        <b>.setHttpStack(new YourHttpStack());</b>       
        .build()                        
        .create(MyService.class);   
</pre>


     <h4>Add different end points for different network calls</h4>
     <p>You can add different end point url for some network calls, it will override the base url.</p>
<pre class='prettyprint'>
    @EndPoint("http://www.google.com")
    @GET("/users")
    void fetchUsers(
          RepoCallBack&lt;List&lt;User>> callBack
    );
</pre>


     <h4>Mocking</h4>
     <p>You can mock your network calls easily by using mock annotation.</p>
     <p><b>@Mock</b> :  Uses auto generate feature mock regarding to your response type</p>
<pre class='prettyprint'>
    @Mock
    @GET("/user")
    void fetchUser(
          RepoCallBack&lt;User> callBack
    );
</pre>
       <p><b>@Mock(path="users.json")</b> : Uses local file to generate mock. Local files must be under assets folder.
         This will return a response with the generated content by given path, with the status code 200 </p>
         
<pre class='prettyprint'>
    @Mock(path="user.json")
    @GET("/user")
    void fetchUser(
          RepoCallBack&lt;User> callBack
    );
</pre>
       <p><b>@Mock(statusCode=404)</b> : Returns a fail response with status code 404 </p>

<pre class='prettyprint'>
    @Mock(statusCode=404)
    @GET("/user")
    void fetchUser(
          RepoCallBack&lt;User> callBack
    );
</pre>

       <p><b>@Mock(statusCode=201)</b> : Returns a success with the status code 201 and auto generated response</p>

<pre class='prettyprint'>
    @Mock(statusCode=201)
    @GET("/user")
    void fetchUser(
          RepoCallBack&lt;User> callBack
    );
</pre>

     <h4>Cookie Management</h4>
     <p>You can easily handle cookies in two ways:</p>
     <ul>
       <li>Set a CookiePolicy and let the CookieManager to use the default CookieStore implementation</li>
     </ul>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        <b>.enableCookies(CookiePolicy.ACCEPT_ALL)</b>     
        .build()                        
        .create(MyService.class);
</pre>
    <ul>
       <li>Provide also your own implementation of CookieStore which will be used by CookieManager</li>
     </ul>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        <b>.enableCookies(new YourCookieStore(), CookiePolicy.ACCEPT_ALL)</b>   
        .build()                        
        .create(MyService.class);
</pre>

     <h4>Certificate Management</h4>
     <p>You can make use of this feature in two ways:</p>
     <p><b>Trust All Certificates:</b> Most of the time test servers do not use a certificate which is signed by a CA.
       Therefore, connections to those servers fail at SSL Handshake step. To solve this, you can let Wasp to accept
       all certificates (Note that, this should only be used for testing purposes because it makes the connections vulnerable to security attacks.)
       </p>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        .trustCertificates()  //Trust All Certificates
        .build()                        
        .create(MyService.class);
</pre>
      <p><b>Certificate Pinning:</b> Create a BKS file of your server certificate and put it under res/raw folder. Than,
         let Wasp use your certificate for SSL Handshake with the server by providing your raw resource id and keystore pasword.
       </p>
<pre class='prettyprint'>
  GitHubService service = new Wasp.Builder(this)    
        .setEndpoint("https://api.github.com")   
        .trustCertificates(R.raw.YOUR_TRUST_STORE, "YOUR_PASSWORD") //Trust only to the given certificate    
        .build()                        
        .create(MyService.class);
</pre>

     <h4>Image Loading</h4>
     <p>You can use Wasp to download and load images to image views easily.</p>
     
     <p><b>Simple usage</b></p>
<pre class='prettyprint'>
Wasp.Image.from(url).to(imageView).load();
</pre>
     <p><b>Advanced options</b></p>
<pre class='prettyprint'>
Wasp.Image.from(url)
      .to(imageView)
      .setErrorResource(errorImage)     // Optional
      .setDefaultResource(defaulImage)  // Optional
      .fit()                            // Optional, in TODO
      .cropCenter()                     // Optional, in TODO
      .resize(100,200)                  // Optional, in TODO
      .load();
</pre>
<br>
        </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
         <p class="copyright">Contributers: <a href="https://github.com/orhanobut">Orhan Obut</a> , 
         <a href="https://github.com/kardeslik">Emmar Kardeslik</a>
         </p>
      </footer>
    </div>

    

  </body>
</html>
